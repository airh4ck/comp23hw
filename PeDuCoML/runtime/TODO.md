## Идея
Куча будет представлять собой 2 банка, один активный, второй - нет. Сборка мусора перекладывает активные указатели из первого банка во второй.

Все ссылки в кучу хранятся где-то на стеке, поэтому при вызове GC будем проходиться по стеку и помечать ещё используемые ссылки (mark). Затем помеченные указатели перемещаем во второй банк (copy).

1. `gc_init` инициализирует кучу и узнает начало стека (stack bottom)
2. `gc_get_stack_top` - когда-то была какая-то функция для дебага, выводит stack top в stdout
3. `gc_stack_scan` выполняет непосредственно проход по стеку. Принимает один аргумент - stack bottom (потому что stack top она и сама узнать может). На каждом элементе стека вызывается `check_pointer`, который должен 1) проверить, указатель это или нет, 2) указывает он в нашу кучу или нет и 3) "пометить", если указывает

## TODO

1. Удостовериться, что `gc_stack_scan` работает (или не работает)
2. Научиться отличать указатели в кучу от интов
3. Удостовериться, что `gc()` в `gc.c` не работает (или работает, но маловероятно)

Если что-нибудь не работает, нужно, конечно, починить =)
Чтобы хоть как-то тестировать в `tmp/gc/` есть `main.c` и `Makefile`, можно симулировать выделение памяти во время работы программы.

## Запуск 
В директории `tmp/gc/`
1. `make riscv`
2. `qemu-riscv64-static riscv_test.out`
